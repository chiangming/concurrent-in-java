# Java memory model

## 线程通信与线程同步

线程之间的通信机制分为共享内存和消息传递两种，Java非并发采用的是共享内存模型。通信是指线程之间以何种机制来交换信息，同步是指程序中用于控制不同线程之间操作发生相对顺序的机制。

java线程之间共享程序的公共状态，通过写-读内存中的公共状态进行隐式通信。而程序员必须显示指定某个方法或代码需要在线程之间互斥执行进行显式同步。

## 内存模型的抽象结构

堆内存（实例域、静态域、数组元素这些**共享变量**）在线程之间共享。

局部变量、方法定义参数和异常处理参数不会在线程之间共享。

JMM定义了线程和主内存之间的抽象关系：

共享变量存储在主内存之中，每个线程都有一个私有的本地内存（缓存、**写缓冲区**等）存储该线程以读/写共享变量的副本。

\[线程A\]  &lt;=&gt; \[本地内存A\(共享变量副本\)\] &lt;=&gt;\[主内存\(共享变量\)\] &lt;=&gt; \[本地内存B\(共享变量副本\)\] &lt;=&gt;\[线程B\] 

线程A与线程B之间的通信需要：

1. 线程A将本地内存A更新过的共享变量刷新到主内存中
2. 线程B到主内存中去读取线程A之前更新过的共享变量

**JMM通过控制主内存与每个线程的本地内存之间的交互提供内存可见性保证。**



## Happens-before

JAVA使用JSR-133内存模型，一个操作执行结果需要对另一个（同线程或不同线程）操作可见\(不一定先执行，仅可见且有序\)，需存在阐述操作之间的内存可见性的happens-before规则如下：

* 程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。
* 监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁
* volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。
* 传递性规则：A-&gt;B, B-&gt;C 则A -&gt;C



## 顺序一致性

数据竞争：在一个线程中写一个变量，另一个线程读同一个变量，写和读没有通过同步（synchronized,volatile和final）来排序。

如果程序是正确同步的，程序的执行结果与该程序在顺序一致性内存模式中执行结果相同。

顺序一致性内存模型

* 一个线程中的所有操作必须按照程序的顺序来执行
* （不管是否同步）所有线程都只能看到单一的操作执行顺序，每个操作都必须原子执行且立刻对所有线程可见。

![](/assets/import.png)![](/assets/import3-2.png)

**JMM没有顺序一致性的保证，“未同步” 程序在JMM中不但整体的执行顺序是无序的，而且所有线程看到的操作执行顺序也可能不一致（数据更改位于本地内存未刷新于主内存导致操作对其他线程不可见）。**











                                                                    

